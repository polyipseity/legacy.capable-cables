//////////////////////////////////////////////////
// TITLE Gradle Build Script
//////////////////////////////////////////////////

import groovy.json.JsonBuilder

import java.util.regex.Pattern

import static java.io.File.separator


/* SECTION build script */

buildscript {
    repositories {
        jcenter()
        maven {
            name = 'Minecraft Forge'
            url = 'https://files.minecraftforge.net/maven'
        }
    }

    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.+'
    }
    // COMMENT Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
}


/* SECTION application */

plugins {
    id 'java'
    id 'scala'
    id 'eclipse'
    id 'idea'
}
apply plugin: 'net.minecraftforge.gradle.forge'

apply from: "$rootDir${separator}gradle${separator}utilities.gradle"
apply from: "$rootDir${separator}gradle${separator}global.gradle"
apply from: "$rootDir${separator}gradle${separator}io${separator}properties${separator}properties.gradle"
apply from: "$rootDir${separator}gradle${separator}io${separator}properties${separator}ext.properties.gradle"


/* SECTION extension variables */

loadExt "$rootDir${separator}buildSrc${separator}ext.properties"

ext {
    // COMMENT game

    minecraftVersion = (minecraftForgeVersion as String).split('-').first()
    minecraftVersions = (minecraftVersion as String).split('\\.')
    minecraftMajor = minecraftVersions.first().toInteger()
    minecraftMinor = minecraftVersions[1].toInteger()
    minecraftVersionRange = "[${minecraftMinor == 0 ? minecraftMajor - 1 : minecraftMajor}.${minecraftMinor == 0 ? Integer.MAX_VALUE : minecraftMinor - 1},$minecraftVersion]"


    // COMMENT versioning

    majorMod = majorMod.toInteger()
    majorApi = majorApi.toInteger()
    minor = minor.toInteger()
    patch = patch.toInteger()
    this.'final' = this.'final'.toBoolean()
    pre = pre.toBoolean()
    releaseCandidate = releaseCandidate.toInteger()
    if (this.'final' && pre) throw new IllegalArgumentException('"final" and "pre" are both "true"!')
    if ((this.'final' || pre) && releaseCandidate != 0) throw new IllegalArgumentException("'${this.'final' ? 'final' : 'pre'}' is 'true' while 'releaseCandidate' is not '0' but '$releaseCandidate'.")


    // COMMENT mod

    authorList = stringToStringList authorList_
    screenshots = stringToStringList screenshots_
    requiredMods = stringToStringList requiredMods_
    dependencies = stringToStringList dependencies_
    dependants = stringToStringList dependants_

    StringBuilder cdSb = new StringBuilder()
    requiredMods.each { cdSb.append "required:$it;" }
    ext.dependencies.each {
        if (cdSb.contains(it as String)) cdSb.replaceFirst Pattern.quote("required:$it"), "required-after:$it"
        else cdSb.append "after:$it;"
    }
    dependants.each {
        if (cdSb.contains(m as String)) cdSb.replaceFirst Pattern.quote("required:$it"), "required-before:$it"
        else cdSb.append "before:$it;"
    }
    combinedDependencies = cdSb.append(combinedDependenciesAdditions).toString()
}


/* SECTION repositories */

repositories {
    gradlePluginPortal()
    jcenter()
    mavenCentral()
    google()
}

stringToStringMap(customRepositories).each { String k, List<String> v -> v.each {
    String[] e = it.split('(?<!\\\\):', 2).collect { evaluateGStringString it.trim().replace('\\:', ':') }
    repositories."$k" {
        name = e.first()
        url = e.last()
    }
}}


/* SECTION configuration */

version = "${minecraftVersion}-${majorMod}.${majorApi}.${minor}.${patch}${project.ext.'final' ? '-final' : pre ? '-beta' : releaseCandidate != 0 ? "-rc$releaseCandidate" : ''}"
group = group_ // COMMENT http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = project.name
description = description_

// COMMENT Need this here so eclipse task generates correctly.
sourceCompatibility = targetCompatibility = 1.8


eclipse {
    classpath {
        downloadSources = downloadJavadoc = true
    }
}
idea {
    module {
        downloadSources = downloadJavadoc = true
    }
}


//noinspection SpellCheckingInspection
minecraft {
    version = minecraftForgeVersion
    runDir = runDir

    // COMMENT the mappings can be changed at any time, and must be in the following format.
    // COMMENT snapshot_YYYYMMDD   snapshot are built nightly.
    // COMMENT stable_#            stables are built at the discretion of the MCP team.
    // COMMENT Use non-default mappings at your own risk. they may not always work.
    // COMMENT simply re-run your setup task after changing the mappings to update your workspace.
    mappings = minecraftMappings
    // COMMENT makeObfSourceJar = false // COMMENT an Srg named sources jar is made by default. uncomment this to disable.
}


configurations {
    shade
    compile.extendsFrom shade
}


//noinspection SpellCheckingInspection
dependencies {
    // COMMENT you may put jars on which you depend on in ./libs
    // COMMENT or you may define them like so..
    // CODE compile 'some.group:artifact:version:classifier'
    // CODE compile 'some.group:artifact:version'

    // COMMENT real examples
    // CODE compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
    // CODE compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

    // COMMENT the 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
    // CODE provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // COMMENT the deobf configurations:  'deobfCompile' and 'deobfProvided' are the same as the normal compile and provided,
    // COMMENT except that these dependencies get remapped to your current MCP mappings
    // CODE deobfCompile 'com.mod-buildcraft:buildcraft:6.0.8:dev'
    // CODE deobfProvided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // COMMENT for more info...
    // COMMENT http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // COMMENT http://www.gradle.org/docs/current/userguide/dependency_management.html

    /* COMMENT
    'compile' is superseded by 'implementation'.
    'provided' is superseded by 'compileOnly'.
    'runtime' is superseded by 'runtimeOnly'.
     */
}

stringToStringMap(customDependencies).each { String k, List<String> v -> v.each { dependencies.add k, evaluateGStringString(it) } }


sourceSets {
    main
    test
    api
}


tasks.sourceMainJava.enabled = false
task processSourceMainJava(type: ProcessResources, description: 'rocess main java.') {
    inputs.property 'expand_modId', project.name
    inputs.property 'expand_name', name_
    inputs.property 'expand_version', version
    inputs.property 'expand_dependencies', combinedDependencies
    inputs.property 'expand_minecraftVersionRange', minecraftVersionRange
    inputs.property 'expand_certificateFingerprint', certificateFingerprint
    inputs.property 'expand_updateJSON', updateJSON
    inputs.property 'expand_group', project.group

    into tasks.sourceMainJava.output

    delete { delete temporaryDir }
    copy {
        from tasks.sourceMainJava.source as FileCollection
        into temporaryDir
    }

    from(temporaryDir) {
        Map<String, Object> e = [:]
        inputs.properties.each { if (it.key.startsWith('expand_')) {
            String k = it.key.replace('expand_', '')
            e.put k, it.value
            e.put "${k}__".toString(), it.value
        }}

        expand e
        
        Binding eb = new Binding(e)
        eachFile {
            File f = file "$temporaryDir.absolutePath/$it.sourcePath"
            f.text = f.text.replaceAll(~/\$(.*)__/) { "\${${it[1]}}" }
            it.path = evaluateGStringStringWithBinding it.path, eb
        }
    }
}
tasks.sourceMainJava.finalizedBy tasks.processSourceMainJava


static <E> String processResourcesList(List<E> l) { l.empty ? '[]' : l.toListString().replace('[', '["').replace(']', '"]').replace(', ', '", "') }

processResources {
    // COMMENT this will ensure that this task is redone when the variables change.

    inputs.property 'expand_modId', project.name
    inputs.property 'expand_name', name_
    inputs.property 'expand_description', project.description
    inputs.property 'expand_version', version
    inputs.property 'expand_minecraftVersion', project.minecraft.version
    inputs.property 'expand_url', url
    inputs.property 'expand_updateUrl', updateUrl
    inputs.property 'expand_updateJSON', updateJSON
    inputs.property 'expand_authorList', processResourcesList(authorList as List<String>)
    inputs.property 'expand_credits', credits
    inputs.property 'expand_logoFile', logoFile
    inputs.property 'expand_screenshots', processResourcesList(screenshots as List<String>)
    inputs.property 'expand_parent', parent_
    inputs.property 'expand_requiredMods', processResourcesList(requiredMods as List<String>)
    inputs.property 'expand_dependencies', processResourcesList(project.ext.dependencies as List<String>)
    inputs.property 'expand_dependants', processResourcesList(dependants as List<String>)
    inputs.property 'expand_pack_format', pack_format


    // COMMENT replace stuff in the to-be-processed files, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include '**/*.in'
        rename ~/(.*)\.in/, '$1'

        // COMMENT replace variables
        Map<String, Object> e = inputs.properties.findAll { it.key.startsWith 'expand_' }.collectEntries { [it.key.replace('expand_', ''), it.value] } as Map<String, Object>

        expand e

        Binding eb = new Binding(e)
        eachFile { it.path = evaluateGStringStringWithBinding it.path, eb }
    }

    // COMMENT copy everything else except the processed files
    from(sourceSets.main.resources.srcDirs) {
        exclude '**/*.in'
    }
}

task copyProcessedResources(type: ProcessResources, description: 'Copy processed resources.') {
    from tasks.processSourceMainJava.destinationDir as File
    into tasks.compileJava.destinationDir
}
tasks.processResources.finalizedBy tasks.copyProcessedResources

task deleteCopiedProcessedResources(type: Delete, description: 'Delete copied processed resources.') {
    delete fileTree(dir: tasks.copyProcessedResources.destinationDir, excludes: ['**/*.class'])
}
tasks.jar.dependsOn tasks.deleteCopiedProcessedResources


test {
    useJUnitPlatform()
    testLogging {
        events 'started', 'passed', 'skipped', 'failed', 'standard_out', 'standard_error'
    }
}


jar {
    configurations.shade.each { from (zipTree(it)) { exclude 'META-INF', 'META-INF/**' }}
}

reobf {
    jar {
        // COMMENT extraLines 'PK: org/ejml your/new/package/here/ejml' // COMMENT shading example
    }
}

stringToStringMap(customDependencies).each { if (it.key == 'shade') it.value.each {
    String p = evaluateGStringString(it as String).split(":", 2).first().replace '.', '/'
    reobf.jar.extraLines "PK: $p ${group.replace '.', '/'}/shaded/$p"
}}


task deobfJar(type: Jar, dependsOn: 'jar') {
    from "$buildDir${separator}sources${separator}main"
    classifier 'dev'
}

/* CODE
task sourceJar(type: Jar, dependsOn: 'sourceMainJava') {
    from "$buildDir${separator}sources${separator}java"
    from "$buildDir${separator}resources${separator}main${separator}java"
    classifier 'sources'
}
*/

task javadocJar(type: Jar, dependsOn: 'javadoc') {
    from "$buildDir${separator}docs${separator}javadoc"
    classifier 'javadoc'
}

tasks.each { if (it instanceof org.gradle.jvm.tasks.Jar) it.exclude { it.directory ? it.path.contains('$') : it.path.endsWith('.in') } }


artifacts {
    archives tasks.deobfJar
    archives tasks.sourceJar
    archives tasks.javadocJar
}


tasks.runClient.outputs.upToDateWhen { false }
tasks.runServer.outputs.upToDateWhen { false }


task saveCurrentGoodSettings(group: 'build', description: "Saves current good settings to '$lastGoodSettingsPath'.") {
    outputs.file lastGoodSettingsPath

    doLast {
        File file = file lastGoodSettingsPath
        createNewFile file

        Wrapper wrapper = tasks.wrapper as Wrapper
        Map<String, Object> json = [
                gradle: [ distributionUrl: wrapper.distributionUrl.replace(wrapper.distributionType.name().toLowerCase(Locale.ROOT), Wrapper.DistributionType.ALL.name().toLowerCase(Locale.ROOT)) ],
                dependencies: [],
                minecraft: [
                        version: minecraftForgeVersion,
                        mappings: minecraftMappings
                ]
        ]
        configurations.each { configuration ->
            if (configuration.canBeResolved) configuration.resolvedConfiguration.firstLevelModuleDependencies.each { json.dependencies.add([configuration: configuration.name, group: it.moduleGroup, name: it.moduleName, version: it.moduleVersion]) }
            else configuration.dependencies.each { json.dependencies.add([configuration: configuration.name, group: it.group, name: it.name, version: it.version]) }
        }
        String jsonText = new JsonBuilder(json).toPrettyString()

        file.write jsonText
        logger.info "'${convertToCanonicalPath lastGoodSettingsPath}':"
        logger.info jsonText
    }
}
tasks.build.finalizedBy tasks.saveCurrentGoodSettings


//noinspection SpellCheckingInspection
task cleanCacheAutomatically(type: Delete, group: "build", description: "Clean old items from cache to reduce space usage.", dependsOn: "saveCurrentGoodSettings") {
    // COMMENT Gradle

    gradle.gradleUserHomeDir.eachDir { it.eachDirMatch(~/[0-9]+[.-][0-9.+-]+/) { if (it.name != gradle.gradleVersion) delete it } }


    // COMMENT Minecraft

    //noinspection SpellCheckingInspection
    String minecraftCachePath = "$gradle.gradleUserHomeDir.absolutePath${separator}caches${separator}minecraft"


    // COMMENT Minecraft Coder Pack
    File mcpDir = file "$minecraftCachePath${separator}de${separator}oceanlabs${separator}mcp${separator}mcp_snapshot"
    if (mcpDir.exists()) mcpDir.eachDir { if ("snapshot_$it.name".toString() != minecraftMappings) delete it }


    // COMMENT Minecraft Forge

    //noinspection SpellCheckingInspection
    File minecraftForgeDir = file("$minecraftCachePath${separator}net${separator}minecraftforge${separator}forge")
    if (minecraftForgeDir.exists()) minecraftForgeDir.eachDir { if (it.name != minecraftForgeVersion) delete it }
}
tasks.saveCurrentGoodSettings.finalizedBy tasks.cleanCacheAutomatically


storeExt()
