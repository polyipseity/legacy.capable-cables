//////////////////////////////////////////////////
// TITLE Source
//////////////////////////////////////////////////

import groovy.io.FileType

import java.util.regex.Pattern

import static java.io.File.separator


/* SECTION check */

apply from: "$utilitiesDir${separator}meta${separator}application.gradle"
checkApply.call(['evaluateGStringString', 'createNewFile'])


/* SECTION methods */

project.ext.makeSourceTasks = { Closure c ->
    tasks.withType(AbstractCompile) { AbstractCompile t ->
        // COMMENT Avoid messing around internal tasks.
        if (name.contains('_')) return

        String taskSourceSetName = name.replace('compile', ''),
               sourceSetName = taskSourceSetName.uncapitalize()
        sourceSetName = sourceSets.find { sourceSetName.startsWith it.name }?.name
        String language = name.replace "compile", ''
        if (sourceSetName == null) sourceSetName = 'main'
        else language = language.replace sourceSetName.capitalize(), ''

        Set<File> sourceSet = sourceSets."$sourceSetName"."${language.uncapitalize()}".srcDirs

        Sync pre = task("preProcess${name.capitalize()}", type: Sync, description: "Prepare sources for processing $sourceSetName $language.") {
            from sourceSet
            into temporaryDir

            doLast {
                destinationDir.eachFileRecurse(FileType.FILES) {
                    // COMMENT standard
                    it.text = it.text.replace('\\', '\\\\').replaceAll(~/\$(.*?)__/) { "\${${it[1]}}" }.replaceAll ~/\$(?!\{)/, '\\\\\\$'
                }
            }
        } as Sync

        Sync process = task("process${name.capitalize()}", type: Sync, description: "Process $sourceSetName $language.", dependsOn: pre) {
            configure c

            into temporaryDir

            from(pre.temporaryDir) {
                Map<String, Object> e = [:]
                inputs.properties.each {
                    if (it.key.startsWith('expand_')) {
                        String k = it.key.replace('expand_', '')
                        e.put k, it.value
                        e.put "${k}__".toString(), it.value
                    }
                }

                expand e

                Binding eb = new Binding(e)
                eachFile {
                    it.path = "${evaluateGStringString.call(it.relativePath.parent.pathString, eb).replace '.', separator}$separator${evaluateGStringString.call it.name, eb}"
                }
            }
        } as Sync
        t.dependsOn process

        t.source = process.destinationDir

        t.finalizedBy task("postProcess${name.capitalize()}", type: Jar, description: "Finalize after processing $sourceSetName $language.") {
            from process.destinationDir
            classifier "$sourceSetName$language"
            destinationDir = file "$buildDir/debug"

            if (createNewFile.call(archivePath)) archivePath.text = 'PK\u0005\u0006\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000'
            gradle.projectsEvaluated { rootProject.dependencies.debug files(archivePath) }
        }

        tasks.withType(Javadoc) { Javadoc t2 ->
            boolean replaced = false
            t2.source = t2.source.findAll {
                boolean r = false
                String p = it.canonicalPath
                sourceSet.each {
                    if (r) return
                    r = p.contains(it.canonicalPath)
                }
                replaced |= r
                !r
            }
            if (replaced) t2.source process.destinationDir
        }
    }
}

// COMMENT append
afterEvaluate {
     tasks.withType(AbstractCompile) {
         //noinspection GrUnresolvedAccess
         options.fork = false
         //noinspection GrUnresolvedAccess
         options.compilerArgs << '-Xlint'

         if (buildType == 'DEBUG') {
             //noinspection GrUnresolvedAccess
             options.verbose = true
         }
     }
}
